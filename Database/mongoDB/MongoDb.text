// ================================
// MongoDB â€” Advanced Aggregation & Query Examples + Notes
// ================================

// === THEORY / Overview ===
// Aggregation in MongoDB uses a _pipeline_ model: the output of one stage becomes input to the next. :contentReference[oaicite:0]{index=0}
// Common pipeline stages include: $match, $project, $group, $sort, $limit, $skip, $unwind, $lookup, $bucket / $bucketAuto, $facet, $set / $addFields / $unset, $setWindowFields (from newer versions) etc. :contentReference[oaicite:1]{index=1}
// Aggregation is used for analytics, reporting, data transformation, joining collections, histogram / bucketing, windowed computations, and more â€” especially when simple find() isnâ€™t enough. :contentReference[oaicite:2]{index=2}

// ================================
// EXAMPLE AGGREGATION PIPELINES
// ================================

// 1) Group + sum/avg + sort + limit â€” e.g. top customers or products by total amount
db.orders.aggregate([
  { $match: { status: "completed", orderDate: { $gte: ISODate("2025-01-01") } } },
  { $group: {
      _id: "$customerId",
      totalSpent: { $sum: "$amount" },
      avgOrderValue: { $avg: "$amount" },
      orderCount: { $sum: 1 }
    }
  },
  { $sort: { totalSpent: -1 } },
  { $limit: 10 }
]);

// 2) Unwind an array field + group â€” e.g. count frequency of array items across documents
db.users.aggregate([
  { $unwind: "$likes" },
  { $group: {
      _id: "$likes",
      count: { $sum: 1 }
    }
  },
  { $sort: { count: -1 } },
  { $limit: 5 }
]);

// 3) Join (lookup) + project â€” for merging data from two collections (like SQL JOIN)
db.orders.aggregate([
  { $match: { status: "completed" } },
  { $lookup: {
      from: "products",
      localField: "productId",
      foreignField: "_id",
      as: "productDetails"
    }
  },
  { $unwind: "$productDetails" },
  { $project: {
      _id: 1,
      customerId: 1,
      amount: 1,
      "productDetails.name": 1,
      "productDetails.category": 1
    }
  }
]);

// 4) Multi-branch aggregation using $facet â€” compute several independent aggregates in one query
db.orders.aggregate([
  { $facet: {
      totalOrders: [ { $count: "count" } ],
      completedOrders: [ { $match: { status: "completed" } }, { $count: "count" } ],
      averageAmount: [ { $group: { _id: null, avgAmount: { $avg: "$amount" } } } ]
    }
  }
]);

// 5) Bucketing / histogram â€” group numeric or date fields into ranges (manual buckets)
db.customers.aggregate([
  { $bucket: {
      groupBy: "$age",
      boundaries: [18, 25, 35, 50, 65],
      default: "65+",
      output: {
        count: { $sum: 1 },
        avgSpending: { $avg: "$spending" }
      }
    }
  }
]);

// 6) Automatic bucketing using $bucketAuto â€” Mongo computes buckets for you based on distribution
db.sales.aggregate([
  { $bucketAuto: {
      groupBy: "$amount",
      buckets: 5,
      output: {
         count: { $sum: 1 },
         totalSales: { $sum: "$amount" }
      }
    }
  }
]);

// 7) Window functions (on MongoDB â‰¥ 5.0) â€” e.g. running totals, moving averages per partition/sort key
db.sales.aggregate([
  { $sort: { date: 1 } },
  { $setWindowFields: {
      partitionBy: "$productId",
      sortBy: { date: 1 },
      output: {
        cumulativeSales: { $sum: "$quantity", window: { documents: ["unbounded", "current"] } },
        avgLast3: { $avg: "$quantity", window: { documents: [-2, "current"] } }
      }
    }
  }
]);

// 8) Combine multiple collections using $unionWith â€” e.g. unify records from two collections and then aggregate
db.collection1.aggregate([
  /* some pipeline on collection1 */
  { $unionWith: "collection2" },
  /* further pipeline on combined results */
  { $match: { status: "active" } },
  { $group: { _id: "$category", count: { $sum: 1 } } }
]);

// 9) Persist aggregated results into another collection â€” using $merge or $out (materialized view / summary collection)
db.orders.aggregate([
  { $group: { _id: "$status", totalAmount: { $sum: "$amount" } } },
  { $merge: { into: "orderSummary", whenMatched: "merge", whenNotMatched: "insert" } }
]);

// 10) Example: Monthly sales totals (by extracting month from date field + grouping)
db.sales.aggregate([
  { $addFields: { month: { $month: "$date" } } },
  { $group: { _id: "$month", total: { $sum: "$amount" } } },
  { $sort: { _id: 1 } }
]);

// ================================
// NOTES / BEST PRACTICES / CONSIDERATIONS
// ================================
// - Always try to $match (filter) early in the pipeline to reduce number of documents processed downstream. :contentReference[oaicite:3]{index=3}
// - Use projection ($project / $addFields / $unset) to limit fields you carry forward â€” reduces memory usage. :contentReference[oaicite:4]{index=4}
// - For large data sets or memory-intensive pipelines, consider using option { allowDiskUse: true } in .aggregate() to allow disk spill. :contentReference[oaicite:5]{index=5}
// - Use $lookup judiciously; joining large collections may be expensive. Sometimes embedding or precomputed data / denormalization might be better depending on access patterns. (Design tradeoffs apply) :contentReference[oaicite:6]{index=6}
// - For complex reporting (multiple aggregates like counts, sums, histograms in single query), $facet + $bucket / $bucketAuto is powerful. :contentReference[oaicite:7]{index=7}
// - If you need time-series or running totals / moving averages, use newer window-stage operators (e.g. $setWindowFields) where MongoDB version supports them. :contentReference[oaicite:8]{index=8}


// ================================
// SAMPLE SCHEMA & DATA (for testing some of above queries) â€” you can adapt to your collections
/*
use shopDB;

db.customers.insertMany([
  { _id: 1, name: "Alice", age: 30, spending: 1200 },
  { _id: 2, name: "Bob",   age: 22, spending: 800 },
  { _id: 3, name: "Charlie", age: 40, spending: 1500 },
  // ... more docs
]);

db.orders.insertMany([
  { _id: 101, customerId: 1, amount: 300, status: "completed", orderDate: ISODate("2025-02-10") },
  { _id: 102, customerId: 2, amount: 450, status: "pending",   orderDate: ISODate("2025-03-01") },
  { _id: 103, customerId: 1, amount: 700, status: "completed", orderDate: ISODate("2025-04-15") },
  // ... more orders
]);

db.sales.insertMany([
  { _id: 201, productId: "P1", date: ISODate("2025-01-05"), amount: 200, quantity: 2 },
  { _id: 202, productId: "P1", date: ISODate("2025-01-15"), amount: 300, quantity: 3 },
  { _id: 203, productId: "P2", date: ISODate("2025-02-10"), amount: 500, quantity: 5 },
  // ... more sales data
]);
*/





// ================================
// MongoDB â€” More Advanced Aggregation & Query Examples + Notes
// (extensions: recursive lookup, array-filtering, nested lookups, conditional logic, materialization, etc.)
// ================================

// === More Advanced / Less-common Aggregation Stages & Use-Cases ===

// 1) Recursive / Graph-style lookup within a collection (hierarchies / tree / graph data) â€” using $graphLookup
db.employees.aggregate([
  {
    $graphLookup: {
      from: "employees",
      startWith: "$managerId",
      connectFromField: "managerId",
      connectToField: "_id",
      as: "managementChain",
      maxDepth: 5,                // optional: limit recursion depth
      depthField: "level"         // optional: track how far the node is from start
    }
  }
]);

// e.g. output: each employee doc gets a field â€œmanagementChainâ€ as an array of all their managers / ancestors. :contentReference[oaicite:1]{index=1}

// 2) Filtering or manipulating array-fields inside documents (e.g. selecting subset of array elements) + aggregation

// Suppose a doc structure: { _id, name, scores: [ { subject: "math", score: 80 }, { subject: "eng", score: 65 }, ... ] }
// We can compute average for only certain subjects (e.g. where score > 70):

db.students.aggregate([
  { $project: {
      name: 1,
      highScores: {
        $filter: {
          input: "$scores",
          as: "s",
          cond: { $gt: ["$$s.score", 70] }
        }
      }
    }
  },
  { $unwind: "$highScores" },
  { $group: {
      _id: "$_id",
      avgHighScore: { $avg: "$highScores.score" }
    }
  }
]);

// This gives, per student, the average of only â€œhighâ€ scores. (You can adapt the condition.)  
// This pattern helps when you need array-level filtering + aggregation.  

// 3) Nested / multi-level lookups (join across multiple collections, then aggregate)  
// Example: Suppose we have collection â€œordersâ€ referencing â€œcustomersâ€, and each customer references â€œregionâ€. Want to get, per region, total sales.

db.orders.aggregate([
  { $match: { status: "completed" } },
  { $lookup: {
      from: "customers",
      localField: "customerId",
      foreignField: "_id",
      as: "cust"
    }
  },
  { $unwind: "$cust" },
  { $lookup: {
      from: "regions",
      localField: "cust.regionId",
      foreignField: "_id",
      as: "region"
    }
  },
  { $unwind: "$region" },
  { $group: {
      _id: "$region.name",
      totalSales: { $sum: "$amount" },
      orderCount: { $sum: 1 }
    }
  },
  { $sort: { totalSales: -1 } }
]);

// This gives per-region aggregated sales â€” demonstrates chaining lookups + group.  

// 4) Conditional logic inside aggregation â€” e.g. categorize data, compute conditional sums / counts  
// Suppose you have orders with an amount field, and you want to bucket into â€œsmallâ€, â€œmediumâ€, â€œlargeâ€ orders, then count each category:

db.orders.aggregate([
  { $project: {
      amount: 1,
      sizeCategory: {
        $switch: {
          branches: [
            { case: { $lte: ["$amount", 100] }, then: "small" },
            { case: { $and: [ { $gt: ["$amount", 100] }, { $lte: ["$amount", 500] } ] }, then: "medium" },
            { case: { $gt: ["$amount", 500] }, then: "large" }
          ],
          default: "unknown"
        }
      }
    }
  },
  { $group: {
      _id: "$sizeCategory",
      count: { $sum: 1 },
      totalAmount: { $sum: "$amount" }
    }
  }
]);

// This lets you categorize and aggregate in one pipeline â€” useful for quick reports / segmentation.  

// 5) Combining multiple analytics: e.g. count, sum, average, distinct values â€” using $facet + $group + $addToSet  

db.orders.aggregate([
  { $facet: {
      summary: [
        { $group: { _id: null, totalOrders: { $sum: 1 }, totalRevenue: { $sum: "$amount" } } }
      ],
      avgOrder: [
        { $group: { _id: null, avgAmount: { $avg: "$amount" } } }
      ],
      customers: [
        { $group: { _id: "$customerId" } },
        { $count: "distinctCustomerCount" }
      ],
      bucketedByAmount: [
        { $bucket: {
            groupBy: "$amount",
            boundaries: [0, 100, 500, 1000, 5000],
            default: "5000+",
            output: {
              count: { $sum: 1 },
              total: { $sum: "$amount" }
            }
          }
        }
      ]
    }
  }
]);

// This returns a document having multiple analytics (summary, avg, distinct count, bucket-histogram) â€” very useful for dashboards / reporting.  

// 6) Materializing aggregated results into another collection â€” using $merge (or $out) â€” useful for reports / summary tables / caching  

db.sales.aggregate([
  { $group: { _id: "$productId", totalQty: { $sum: "$quantity" }, totalAmount: { $sum: "$amount" } } },
  { $merge: {
      into: "productSalesSummary",
      whenMatched: "merge",        // merge with existing doc if present
      whenNotMatched: "insert"     // insert new doc if not exist
    }
  }
]);

// Now â€œproductSalesSummaryâ€ has one doc per productId with aggregated totals â€” can be used for fast lookups later.  

// 7) Handling large data sets â€” using allowDiskUse, early $match, limiting fields  

db.bigCollection.aggregate([
  { $match: { status: "active", createdAt: { $gte: ISODate("2025-01-01") } } },
  { $project: { field1: 1, field2: 1 /* only necessary fields */ } },
  { /* further heavy operations like $group / $lookup / $sort */ }
], { allowDiskUse: true });

// Setting allowDiskUse helps avoid memory errors / limit issues on big pipelines.  

// ================================
// Extended Theory / Interview-level Concepts & Edge Cases to Know
// ================================

// â€¢ Recursive / graph-structured data traversal: using $graphLookup â€” for organizational charts, hierarchies, tree- or graph-like data structures. Understand parameters like startWith, connectFromField/connectToField, maxDepth, depthField, and memory/disk usage constraints. :contentReference[oaicite:2]{index=2}

// â€¢ Array-filtering + aggregation: using $filter, $unwind + $group â€” when documents have embedded arrays and you need to filter & aggregate based on array contents. Useful for scores, tags, history arrays, etc.  

// â€¢ Multi-level joins / nested lookups: when documents reference other collections (and those further reference others). Understand the performance implications, and when embedding vs referencing makes sense.  

// â€¢ Conditional aggregation / bucketing inside aggregation â€” using $switch / $cond / $bucket / $bucketAuto â€” for segmentation, categorization, histograms.  

// â€¢ Faceted aggregation / dashboards â€” using $facet to compute multiple independent aggregations in a single pass â€” efficient for reporting or analytics endpoints. :contentReference[oaicite:3]{index=3}

// â€¢ Materializing aggregated output â€” using $merge / $out â€” to build summary collections / materialized views inside MongoDB, useful in analytics-heavy applications.  

// â€¢ Performance & resource constraints: when pipelines become heavy (joins, recursion, large data, grouping) â€” need proper indexing, early filtering ($match), projecting only necessary fields, possibly use allowDiskUse, understand memory limits and disk spill behaviour.  

// â€¢ Schema design considerations given advanced queries: if you have frequent nested lookups or graph-like relations, sometimes embedding or denormalizing can give better performance than frequent $lookup/$graphLookup. Also consider tradeoffs (data duplication vs query performance).  

// â€¢ Awareness of MongoDB version / feature support: e.g. $graphLookup, $bucketAuto, $merge â€” only available in certain versions; likewise behaviour of memory, sharding with $graphLookup, etc. Always check version compatibility. :contentReference[oaicite:4]{index=4}

/* =================================================================== */
/* === Sample Data Schema / Setup for Testing Some Patterns ===

use companyDB;

db.employees.insertMany([
  { _id: 1, name: "Alice", managerId: null },
  { _id: 2, name: "Bob",   managerId: 1 },
  { _id: 3, name: "Charlie", managerId: 2 },
  { _id: 4, name: "David", managerId: 2 },
  { _id: 5, name: "Eve", managerId: 3 }
]);

db.orders.insertMany([
  { _id: 101, customerId: 201, amount: 120, status: "completed", items: ["pen","notebook"] },
  { _id: 102, customerId: 202, amount: 550, status: "completed", items: ["laptop", "mouse"] },
  { __id: 103, customerId: 201, amount: 80, status: "pending", items: ["book"] },
  { _id: 104, customerId: 203, amount: 300, status: "completed", items: ["chair", "table"] }
]);

db.customers.insertMany([
  { _id: 201, name: "CustA", regionId: 1 },
  { _id: 202, name: "CustB", regionId: 2 },
  { _df: 203, name: "CustC", regionId: 1 }
]);

db.regions.insertMany([
  { _id: 1, name: "North" },
  { _id: 2, name: "South" }
]);

/* Use above sample data to test queries above */
/* =================================================================== */



// ================================
// MongoDB â€” More Advanced & Complex Aggregation / Query Examples
// ================================

// 1) Recursive / hierarchical queries â€” using $graphLookup (for tree/graph data, e.g. org charts, categories, friends, etc.)
db.employees.aggregate([
  {
    $graphLookup: {
      from: "employees",
      startWith: "$managerId",             // or "$reportsTo" or appropriate field
      connectFromField: "managerId",       // field in other docs that points upward
      connectToField: "_id",               // match on _id (or other unique field)
      as: "managementChain",
      maxDepth: 5,                         // optional: limit recursion depth
      depthField: "level"                  // optional: include depth info
    }
  }
]);

// 2) Complex joins + nested lookups + aggregation â€” e.g. join 2 collections, then group by some field from second collection
db.orders.aggregate([
  { $match: { status: "completed" } },
  { $lookup: {
      from: "customers",
      localField: "customerId",
      foreignField: "_id",
      as: "cust"
    }
  },
  { $unwind: "$cust" },
  { $lookup: {
      from: "regions",
      localField: "cust.regionId",
      foreignField: "_id",
      as: "region"
    }
  },
  { $unwind: "$region" },
  { $group: {
      _id: "$region.name",
      totalSales: { $sum: "$amount" },
      countOrders: { $sum: 1 }
    }
  },
  { $sort: { totalSales: -1 } }
]);

// 3) Conditional bucketing / categorization inside aggregation â€” categorize and count based on dynamic ranges / thresholds
db.transactions.aggregate([
  { $project: {
      amount: 1,
      category: {
        $switch: {
          branches: [
            { case: { $lte: ["$amount", 100] }, then: "low" },
            { case: { $and: [ { $gt: ["$amount", 100] }, { $lte: ["$amount", 500] } ] }, then: "medium" },
            { case: { $gt: ["$amount", 500] }, then: "high" }
          ],
          default: "unknown"
        }
      }
    }
  },
  { $group: {
      _id: "$category",
      count: { $sum: 1 },
      total: { $sum: "$amount" }
    }
  },
  { $sort: { total: -1 } }
]);

// 4) Multi-facet analytics / reports â€” using $facet to compute multiple summaries in one query
db.sales.aggregate([
  { $facet: {
      totalSales: [
        { $group: { _id: null, total: { $sum: "$amount" } } }
      ],
      salesByProduct: [
        { $group: { _id: "$productId", total: { $sum: "$amount" } } },
        { $sort: { total: -1 } },
        { $limit: 10 }
      ],
      salesByRegion: [
        { $group: { _id: "$region", total: { $sum: "$amount" } } },
        { $sort: { total: -1 } }
      ],
      monthlyCounts: [
        { $addFields: { month: { $month: "$date" } } },
        { $group: { _id: "$month", count: { $sum: 1 }, totalAmt: { $sum: "$amount" } } },
        { $sort: { _id: 1 } }
      ]
    }
  }
]);

// 5) Window-based analyses (for time-series or ordered data) â€” if MongoDB version supports window ops (>= 5.x)
db.sales.aggregate([
  { $sort: { date: 1 } },  // important: sort first
  { $setWindowFields: {
      partitionBy: "$productId",  // or null to do global window
      sortBy: { date: 1 },
      output: {
        runningTotal: { $sum: "$quantity", window: { documents: ["unbounded", "current"] } },
        movingAvgLast3: { $avg: "$quantity", window: { documents: [-2, 0] } },
        rankByRevenue: { $denseRank: { sortBy: { amount: -1 } } }
      }
    }
  }
]);

// 6) Combining multiple collections/unions + aggregate â€” e.g. merging similar data spread across collections
db.collectionA.aggregate([
  /* pipeline on collectionA */
  { $unionWith: "collectionB" },
  /* further pipeline on combined results */
  { $match: { status: "active" } },
  { $group: { _id: "$category", count: { $sum: 1 } } }
]);

// 7) Materializing summary data or caching aggregated results â€” write output to a separate collection using $merge
db.orders.aggregate([
  { $group: { _id: "$customerId", totalSpent: { $sum: "$amount" }, orderCount: { $sum: 1 } } },
  { $merge: {
      into: "customerOrderSummary",
      whenMatched: "merge",
      whenNotMatched: "insert"
    }
  }
]);

// 8) Filtering & aggregating within embedded arrays â€” e.g. documents have array field, filter array, then aggregate based on filtered array
db.students.aggregate([
  { $project: {
      name: 1,
      highScores: {
        $filter: {
          input: "$scores",        // scores: array of subdocs {subject, score}
          as: "s",
          cond: { $gt: ["$$s.score", 70] }
        }
      }
    }
  },
  { $unwind: "$highScores" },
  { $group: {
      _id: "$_id",
      avgHighScore: { $avg: "$highScores.score" },
      countHigh: { $sum: 1 }
    }
  }
]);

// 9) Combining conditional logic, bucketing, and grouping for segmentation & analytics â€” e.g. segment users by age groups and compute stats
db.users.aggregate([
  { $project: {
      age: 1,
      spending: 1,
      ageGroup: {
        $switch: {
          branches: [
            { case: { $lte: ["$age", 18] }, then: "<=18" },
            { case: { $and: [ { $gt: ["$age", 18] }, { $lte: ["$age", 35] } ] }, then: "19-35" },
            { case: { $gt: ["$age", 35] }, then: "36+" }
          ],
          default: "unknown"
        }
      }
    }
  },
  { $group: {
      _id: "$ageGroup",
      totalUsers: { $sum: 1 },
      avgSpending: { $avg: "$spending" }
    }
  }
]);

// 10) Report-style query with sorting, pagination, projection + aggregation â€” for dashboards or APIs
db.orders.aggregate([
  { $match: { status: { $in: ["completed", "shipped"] } } },
  { $lookup: {
      from: "customers",
      localField: "customerId",
      foreignField: "_id",
      as: "cust"
    }
  },
  { $unwind: "$cust" },
  { $project: {
      orderId: "$_id",
      customerName: "$cust.name",
      amount: 1,
      orderDate: 1,
      status: 1
    }
  },
  { $sort: { orderDate: -1 } },
  { $skip: 20 },  // for pagination
  { $limit: 10 }
]);
ðŸ§  Why / When These Patterns Are Useful (and What to Watch Out For)
Hierarchical / Graph-data: $graphLookup is powerful when you have nested or recursive data (e.g. employee â†’ manager â†’ higher-level managers; categories with subcategories). 
MongoDB
+1

Complex Joins + Aggregation: Using multiple $lookups (or join + group) helps when your data is normalized across collections and you need aggregated reports (sales per region, orders per customer, etc.).

Segmentation & Bucketing: Conditional logic + grouping helps categorize data dynamically (e.g. small/medium/large orders, user-age groups, spending brackets).

Dashboards & Reports: $facet lets you compute multiple summaries in one query (totals, breakdowns, histograms, monthly stats) â€” useful for dashboards or analytics endpoints. 
MongoDB
+1

Time-series / Trend / Running totals: Window functions (where supported) help you compute running totals, moving averages, ranking over time â€” great for sales trends, usage history, etc. 
chillucoder.com
+1

Embedded Arrays & Complex Documents: Filtering and aggregating nested arrays lets you derive metrics from complex document structures (e.g. user activities, nested transactions, scores, events).

Data Materialization / Caching: $merge is useful when you need to persist aggregated or transformed data (e.g. summary collections) instead of recomputing on every request â€” helps when data volume is large and queries heavy.

Pagination + Join + Projection: Combined operations are relevant for API endpoints â€” retrieving joined and filtered data + sorting + pagination.











Advanced Theory Questions for MongoDB Interviews

What is a replica set in MongoDB â€” and how does it ensure high availability?

Explain what a replica set is (primary + secondaries + optionally arbiter), how replication works, and how automatic failover helps if primary fails. 
GeeksforGeeks
+2
DEV Community
+2

What are trade-offs or limitations (e.g. eventual consistency, replication lag)?

What is sharding in MongoDB â€” how does it work, and when would you use it?

Define sharding: splitting data across multiple servers (â€œshardsâ€) using a shard key. 
newtechrise.com
+2
Howik
+2

What are good/sharding-key selection criteria? What are potential problems (hot shards, uneven load, complexity)?

What are storage engines in MongoDB â€” and what are differences between them (e.g. WiredTiger vs legacy)?

What are benefits of the default engine (document-level concurrency, compression, journaling) vs older engines. 
GeeksforGeeks
+1

When would engine choice matter (workload type, concurrency, disk usage)?

Explain transactions in MongoDB â€” what ACID guarantees does MongoDB offer? When to use transactions vs simple operations?

MongoDB (since v4.0) supports multi-document ACID transactions (on replica sets or sharded clusters) â€” useful when multiple operations must succeed or fail together. 
Howik
+1

What are trade-offs: performance, complexity, when it may make more sense to design around single-document operations (embedding)?

What is the aggregation framework / pipeline â€” how is it different from simple query/filter operations or from Map-Reduce?

Describe pipeline stages (match, group, project, etc.) where documents flow through stages to produce aggregated / transformed output. 
GeeksforGeeks
+1

When is aggregation favorable vs simple queries? And what are the limitations (memory usage, performance, indexes, complexity)?

What are capped collections and when would you use them?

Explain what a capped collection is: fixed-size collection that overwrites oldest documents when limit reached. Useful for logs, caching, fixed-window data. 
DataCamp
+1

What is a â€œcovered queryâ€ in MongoDB â€” and how can indexing and query design optimize performance?

Define covered query (where index contains all fields needed by query and result â€” no need to fetch full documents). 
Medium
+1

How would you design indexes + schema + queries to maximize performance (use cases, caveats)?

What is the difference between embedding vs referencing in schema design â€” when to choose one over the other?

Explain embedding (nested documents / arrays) vs referencing (separate collections + linking via ids), and trade-offs (data duplication, update complexity, read performance, normalization vs denormalization). This influences when to use joins / lookups vs simpler access. 
GeeksforGeeks
+1

How does sharded cluster architecture work (shards + config servers + mongos)? What are config servers / mongos / chunk migrations / balancing?

Describe the roles: shards store data, config servers hold metadata, mongos routes queries. Data is split into chunks based on shard key; shards may rebalance as data grows. 
InterviewZilla
+2
jsonworld.com
+2

What are trade-offs: complexity in operations, shard key choice, eventual consistency across shards, latency, operational overhead.

What are TTL (Time To Live) indexes in MongoDB and when to use them?

Explain TTL indexes â€” automatically expire / delete documents after a specified time (useful for sessions, logs, temporary data). 
GeeksforGeeks
+1

How does indexing work in MongoDB â€” what types of indexes are there (single-field, compound, TTL, geospatial, hashed, text), and when to use each?

Explain different index types and use cases; how indexes affect read performance, write cost, storage; and how to choose index strategy. 
GeeksforGeeks
+2
jsonworld.com
+2

How do backup, restore, and disaster recovery work in MongoDB environments (including replica sets / sharded clusters)?

What tools / strategies are used (dump/restore, snapshots, replica-based backups), and what considerations (consistency, downtime, storage) apply. 
Verve Copilot
+1

What are the security best practices for MongoDB (authentication, authorization, encryption, network access, role-based access control)?

While not strictly â€œaggregation or query,â€ many interviews expect awareness of securing databases: enabling auth, TLS/SSL, limiting network exposure, RBAC, etc. 
DEV Community
+1

When is MongoDB NOT a great fit? What are limitations / trade-offs compared to relational databases or other NoSQL stores?

Think about cases needing complex transactions, rigid schema, many-to-many relationships with heavy joins, high consistency demands, relational constraints, etc. Also performance implications depending on data model & query patterns.

Explain how data modeling in MongoDB differs from relational databases and how you approach schema design when using MongoDB.

Understand documents vs tables, normalization vs denormalization, embedding vs referencing, design for queries rather than normalization, foresee growth/sharding needs. 
Shiksha
+1
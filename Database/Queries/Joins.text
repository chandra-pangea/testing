-- Create the 'departments' table
CREATE TABLE departments (
    department_id INT PRIMARY KEY,
    department_name VARCHAR(50) NOT NULL
);

-- Create the 'employees' table
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    employee_name VARCHAR(50) NOT NULL,
    department_id INT,
    manager_id INT,
    salary INT
);

-- Create the 'categories' table
CREATE TABLE categories (
    category_id INT PRIMARY KEY,
    category_name VARCHAR(50)
);

CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(50),
    category_id INT,
    FOREIGN KEY (category_id) REFERENCES categories(category_id)
);



-- Insert data into the 'departments' table
INSERT INTO departments (department_id, department_name) VALUES
    (1, 'Human Resources'),
    (2, 'Engineering'),
    (3, 'Finance'),
    (4, 'Sales'),
    (6,'AI&ML');

-- Insert data into the 'employees' table
INSERT INTO employees (employee_id, employee_name, department_id, manager_id, salary) VALUES
    (1, 'Alice', 1, NULL, 100),
    (2, 'Bob', 2, 5, 200),
    (3, 'Charlie', 3, NULL, 150),
    (4, 'David', 4, 6, 300),
    (5, 'Emma', 2, NULL, 170),
    (6, 'Frank', 4, NULL, 220),
    (7, 'Grace', 2, 5, 310),
    (8, 'Hannah', 1, 1, 330),
    (9, 'Ivan', 4, 6, 350),
    (10, 'Jack', 3, 3, 50),
    (11, 'Jacky', 5, 3, 50);
    
    SELECT*from employees;
--    SELECT*from employees;
    
SELECT
    e1.employee_name as employee_name,
    e2.employee_name as manager_name
FROM
    employees e1
INNER JOIN
    employees e2  ON e1.manager_id = e2.employee_id;
    
    -- SELECT AVG(salary)from employees;
    
    -- SELECT employee_name,salary
    -- from employees
    -- where salary > (SELECT AVG(salary)from employees)
    -- order by salary ;
    
    
    
    -- SELECT employee_name as manager_name 
    -- from employees
    -- where manager_id IN (SELECT employee_id from employees)
    
    
    Select e.employee_name e, 
    (select e2.employee_name from employees e2 where e2.employee_id = e.manager_id) as manager_name 
    from employees e
    where e.manager_id IS NOT NULL ;
    
DELIMITER $$
CREATE PROCEDURE GetFirstDivision (
)
BEGIN
    SELECT *
    FROM Students
    WHERE percentage_in_12th > 70;
END $$

DELIMITER;
    
    
--     SELECT
--     e.employee_id,
--     e.employee_name,
--     e.salary
-- FROM
--     employees e
-- JOIN
--     (
--         SELECT
--             AVG(salary) AS avg_salary
--         FROM
--             employees
--     ) avg_table ON e.salary > avg_table.avg_salary;
    
    
    
    
--     Using a Join (Better Approach):
-- SELECT
--     p.product_id,
--     p.product_name,
--     c.category_name
-- FROM
--     products p
-- LEFT JOIN
--     categories c ON p.category_id = c.category_id;



-- SELECT
--     product_id,
--     product_name,
--     (
--         SELECT
--             category_name
--         FROM
--             categories
--         WHERE
--             categories.category_id = products.category_id
--     ) AS category_name
-- FROM
--     products;
    
    
    
    
    
    
    
    
    
    
-- INSERT INTO categories (category_id, category_name) VALUES
--     (1, 'Electronics'),
--     (2, 'Furniture'),
--     (3, 'Clothing');

-- INSERT INTO products (product_id, product_name, category_id) VALUES
--     (1, 'Laptop', 1),
--     (2, 'Table', 2),
--     (3, 'Shirt', 3),
--     (4, 'Headphones', 1),
--     (5, 'Sofa', NULL); -- Product without a category
    
    
  -- SELECT categories.category_name,products.product_name
  -- from products
  -- CROSS JOIN categories;
  
  
 -- where categories.category_id=products.category_id;  
 
-- SELECT
--     p.product_id,
--     p.product_name,
--     c.category_id,
--     c.category_name
-- FROM
--     categories c
-- CROSS JOIN
--     products p;
    
   --  SELECT*from departments;
    
-- SELECT
--     employees.employee_name,
--     departments.department_name
-- FROM
--     employees 
-- INNER JOIN
--     departments  ON employees.department_id = departments.department_id;
    
    
        

-- SELECT
--     employees.employee_name,
--     departments.department_name
-- FROM
--     employees 
-- LEFT JOIN
--     departments  ON employees.department_id = departments.department_id;
    
    
        

-- SELECT
--     employees.employee_name,
--     departments.department_name
-- FROM
--     employees 
-- RIGHT JOIN
--     departments  ON employees.department_id = departments.department_id;
    
    
    

-- SELECT
--     employees.employee_name,
--     departments.department_name
-- FROM
--     employees 
-- RIGHT JOIN
--     departments  ON employees.department_id = departments.department_id
        
--   union      
    
-- SELECT
--     employees.employee_name,
--     departments.department_name
-- FROM
--     employees 
-- LEFT JOIN
--     departments  ON employees.department_id = departments.department_id;
    
    

    
    
  
    
  -- Lets Create a simple Social Media App.

-- User can create their Accounts.
-- User Can have Friends.
-- Friends Can View User's Posts.
-- Post's Can be liked and comment can be made on a post by User's Friends.
-- Comments can be replied and comments can also be liked.

-- DROP DATABASE
DROP DATABASE SOCIAL_MEDIA_APP;

-- CREATE THE DATABASE
CREATE DATABASE SOCIAL_MEDIA_APP;

SHOW DATABASES;

-- USE DATABASE
USE SOCIAL_MEDIA_APP;

-- SHOW TABLES OF USED DATABASE
SHOW TABLES;

-- DROP TABLE
DROP TABLE USER;

-- CREATE USER TABLE
CREATE TABLE USER(
USER_ID INT PRIMARY KEY AUTO_INCREMENT,
USER_NAME VARCHAR(50) NOT NULL,
GENDER VARCHAR(10) NOT NULL,
DOB DATE NOT NULL
);

-- DESCRIBE A TABLE
DESCRIBE USER;


-- INSERT INTO USER TABLE
INSERT INTO 
USER 
(USER_NAME, GENDER, DOB) 
VALUES 
('USER_X', 'MALE','1995-02-02'),
('USER_Y', 'FEMALE','1996-02-12'),
('USER_Z', 'MALE','1994-05-10');

-- SELECT DATA FROM SUER
SELECT * FROM USER;

-- CREATE CONTACT DETAILS TABLE
CREATE TABLE CONTACT_DETAILS (
CONTACT_ID INT PRIMARY KEY AUTO_INCREMENT,
USER_ID INT NOT NULL,
CONTACT_TYPE VARCHAR(20) NOT NULL,
FOREIGN KEY (USER_ID) REFERENCES USER(USER_ID)
);

-- DESCRIBE CONTACT DETAILS
DESCRIBE CONTACT_DETAILS;

-- ADD A COLUMN IN CONTACT DETAILS TABLE
ALTER TABLE CONTACT_DETAILS ADD COLUMN CONTACT_VALUE VARCHAR(50) NOT NULL AFTER USER_ID;

-- INSERT INTO CONTACT DETAILS
INSERT INTO 
CONTACT_DETAILS 
(USER_ID, CONTACT_VALUE, CONTACT_TYPE)
VALUES
(1, '9126417032','PHONE_NUMBER'),
(2, '9126417031','PHONE_NUMBER'),
(3, 'Z@GMAIL.COM','EMAIL');

-- SELECT CONTACT DETAILS
SELECT * FROM CONTACT_DETAILS;

SELECT * FROM USER;

-- CREATE ADDRESS DETAILS TABLES
CREATE TABLE ADDRESS_DETAILS (
ADDRESS_ID INT PRIMARY KEY AUTO_INCREMENT,
USER_ID INT NOT NULL,
HOUSE_NO VARCHAR(50) NOT NULL,
HOUSE_NAME VARCHAR(100),
ROAD VARCHAR(100) NOT NULL,
AREA VARCHAR(100),
DISTRICT VARCHAR(100) NOT NULL,
STATE VARCHAR(100) NOT NULL,
COUNTRY VARCHAR(100) NOT NULL,
PINCODE VARCHAR(10) NOT NULL,
FOREIGN KEY (USER_ID) REFERENCES USER(USER_ID)
);

-- TRUNCATE TABLE ADDRESS DETAILS
TRUNCATE TABLE ADDRESS_DETAILS;

-- SELECT * FROM ADDRESS DETAILS
SELECT * FROM ADDRESS_DETAILS;

-- INSERT DATA INTO ADDRRESS DETAILS
INSERT INTO ADDRESS_DETAILS (USER_ID, HOUSE_NO, ROAD, DISTRICT, STATE, COUNTRY, PINCODE)
VALUES 
(1, '101', 'Nice Road', 'Bangalore', 'Karnataka', 'INDIA', '12345'),
(2, '202', 'Electronic City Road', 'Bangalore', 'Karnataka', 'INDIA', '67890'),
(3, '303', 'Bellandur Road', 'Bangalore', 'Karnataka', 'INDIA', '560035');

-- SELECT DATA FROM ADDRESS DETAILS
SELECT * FROM ADDRESS_DETAILS;

-- DROP TABLE FRIENDSHIP_DETAILS
DROP TABLE FRIENDSHIP_DETAILS;

-- CREATE TABLE FRIENDSHIP DETAILS
CREATE TABLE FRIENDSHIP_DETAILS(
USER_ID_1 INT NOT NULL,
USER_ID_2 INT NOT NULL,
FRIENDSHIP_SINCE DATE NOT NULL,
FREINDSHIP_HASH VARCHAR(90) AS (
        CONCAT(LEAST(USER_ID_1, USER_ID_2), GREATEST(USER_ID_1, USER_ID_2))
    ) STORED, -- GENERATED COLUMN
PRIMARY KEY (FREINDSHIP_HASH),
FOREIGN KEY (USER_ID_1) REFERENCES USER(USER_ID),
FOREIGN KEY (USER_ID_2) REFERENCES USER(USER_ID)
);

-- INSERT DATA INTO FRIEND
INSERT INTO FRIENDSHIP_DETAILS (USER_ID_1, USER_ID_2, FRIENDSHIP_SINCE)
VALUES (1, 2, '2024-01-15');

SELECT  * FROM FRIENDSHIP_DETAILS;

INSERT INTO FRIENDSHIP_DETAILS (USER_ID_1, USER_ID_2, FRIENDSHIP_SINCE)
VALUES (3, 1, '2024-01-15'); -- PRIMARY KEY DUPLICATES

-- GET DATA FROM FRIENDSHIP_DETAILS;
SELECT * FROM FRIENDSHIP_DETAILS;



-- CAN WE DO IT WITH TRIGGERS?

-- DROP TABLE FRIENDSHIP_DETAILS
DROP TABLE FRIENDSHIP_DETAILS;

-- CREATE TABLE FRIENDSHIP DETAILS
CREATE TABLE FRIENDSHIP_DETAILS(
USER_ID_1 INT NOT NULL,
USER_ID_2 INT NOT NULL,
FRIENDSHIP_SINCE DATE NOT NULL,
FREINDSHIP_HASH VARCHAR(90) PRIMARY KEY,
FOREIGN KEY (USER_ID_1) REFERENCES USER(USER_ID),
FOREIGN KEY (USER_ID_2) REFERENCES USER(USER_ID)
);

SELECT * FROM FRIENDSHIP_DETAILS;

-- CREATE A TRIGGER

DELIMITER $$
CREATE TRIGGER BEFORE_FRIENDSHIP_INSERT
BEFORE INSERT ON FRIENDSHIP_DETAILS
FOR EACH ROW
BEGIN
	DECLARE HASH_VALUE VARCHAR(90);
   
    SET HASH_VALUE = CONCAT(LEAST(NEW.USER_ID_1, NEW.USER_ID_2), GREATEST(NEW.USER_ID_1, NEW.USER_ID_2));

	SET NEW.FREINDSHIP_HASH = HASH_VALUE;
END $$
DELIMITER ;

-- INSERT DATA INTO FRIEND
INSERT INTO FRIENDSHIP_DETAILS (USER_ID_1, USER_ID_2, FRIENDSHIP_SINCE)
VALUES (1, 2, '2024-01-15');

SELECT * FROM FRIENDSHIP_DETAILS;

INSERT INTO FRIENDSHIP_DETAILS (USER_ID_1, USER_ID_2, FRIENDSHIP_SINCE)
VALUES (2, 1, '2024-01-15'); -- DUPLICATE KEY ERROR

INSERT INTO FRIENDSHIP_DETAILS (USER_ID_1, USER_ID_2, FRIENDSHIP_SINCE)
VALUES (3, 1, '2024-01-15');


-- CREATE MEDIA DETAILS
CREATE TABLE MEDIA_DETAILS (
    MEDIA_ID INT PRIMARY KEY AUTO_INCREMENT,
    MEDIAL_URL VARCHAR(200) NOT NULL,
    MEDIA_TYPE VARCHAR(20) NOT NULL
);

-- INSERT DATA INTO MEDIA DETAILS
INSERT INTO MEDIA_DETAILS(MEDIAL_URL, MEDIA_TYPE)
VALUES 
('http://imageurl.com/nature.jpg', 'IMAGE');

-- GET MEDIA DETAILS DATA
SELECT * FROM MEDIA_DETAILS;

-- CREATE POST TABLE
DROP TABLE POST_DETAILS;

CREATE TABLE POST_DETAILS (
    POST_ID INT PRIMARY KEY AUTO_INCREMENT,
    USER_ID INT NOT NULL,
    CONTENT TEXT NOT NULL,
    POST_DATE DATE NOT NULL,
    POST_TYPE VARCHAR(20) NOT NULL,
    MEDIA_ID INT,
    FOREIGN KEY (USER_ID) REFERENCES USER(USER_ID),
    FOREIGN KEY (MEDIA_ID) REFERENCES MEDIA_DETAILS(MEDIA_ID)
);

-- INSERT DATA INTO POST_DETAILS
INSERT INTO POST_DETAILS (USER_ID, CONTENT, POST_DATE, POST_TYPE, MEDIA_ID)
VALUES 
(1, 'Hello World!', '2025-02-28', 'TEXT',NULL),
(2, 'Nature Photography', '2025-02-27', 'IMAGE', 1);

-- GET DATA FROM POST DETAILS
SELECT * FROM POST_DETAILS;

-- REACTION_DETAILS TABLES
DROP TABLE REACTION_DETAILS;

CREATE TABLE REACTION_DETAILS (
    REACTION_ID INT PRIMARY KEY AUTO_INCREMENT,
    REF_ENTITY_ID INT NOT NULL,
    USER_ID INT NOT NULL,
    REACTION_TYPE VARCHAR(20) NOT NULL,
    REACTION_DATE DATE NOT NULL,
    REF_ENTITY_TYPE ENUM('POST', 'COMMENT') NOT NULL,
    FOREIGN KEY (USER_ID) REFERENCES USER(USER_ID),
    UNIQUE KEY (REF_ENTITY_ID, REF_ENTITY_TYPE, USER_ID)
);

SHOW INDEX FROM REACTION_DETAILS;

-- INSERT DATA INTO REACTION_DETAILS
-- User 1 likes Post 1
INSERT INTO REACTION_DETAILS (REF_ENTITY_ID, USER_ID, REACTION_TYPE, REACTION_DATE, REF_ENTITY_TYPE)
VALUES (1, 1, 'LIKE', '2024-02-28', 'POST');

-- User 1 likes Post 100
INSERT INTO REACTION_DETAILS (REF_ENTITY_ID, USER_ID, REACTION_TYPE, REACTION_DATE, REF_ENTITY_TYPE)
VALUES (100, 1, 'LIKE', '2024-02-28', 'POST');

-- User 1 likes Comment 200
INSERT INTO REACTION_DETAILS (REF_ENTITY_ID, USER_ID, REACTION_TYPE, REACTION_DATE, REF_ENTITY_TYPE)
VALUES (200, 1, 'LIKE', '2024-02-28', 'COMMENT');

-- User 1 tries to like Post 100 again (Duplicate Reaction - Will Fail)
INSERT INTO REACTION_DETAILS (REF_ENTITY_ID, USER_ID, REACTION_TYPE, REACTION_DATE, REF_ENTITY_TYPE)
VALUES (100, 1, 'LIKE', '2024-02-28', 'POST');

SELECT * FROM REACTION_DETAILS;

-- CREATE COMMENT TABLE
CREATE TABLE COMMENT_DETAILS (
    COMMENT_ID INT PRIMARY KEY AUTO_INCREMENT,
    POST_ID INT,
    USER_ID INT,
    CONTENT TEXT NOT NULL,
    COMMENT_DATE DATE NOT NULL,
    PARENT_COMMENT_ID INT,
    FOREIGN KEY (POST_ID) REFERENCES POST_DETAILS(POST_ID),
    FOREIGN KEY (USER_ID) REFERENCES USER(USER_ID),
    FOREIGN KEY (PARENT_COMMENT_ID) REFERENCES COMMENT_DETAILS(COMMENT_ID)
);

-- INSERT DATA INTO COMMENT
INSERT INTO COMMENT_DETAILS (POST_ID, USER_ID, CONTENT, COMMENT_DATE, PARENT_COMMENT_ID)
VALUES 
(1, 2, 'Nice Post!', '2025-02-28', NULL),
(1, 3, 'Thank you!', '2025-02-28', 1);

SELECT * FROM COMMENT_DETAILS;


SELECT * FROM USER;

-- ALTER TABLE ADD
ALTER TABLE USER
ADD PROFILE_PICTURE VARCHAR(100) AFTER DOB;

-- ALTER TABLE MODIFY
ALTER TABLE USER
MODIFY USER_NAME VARCHAR(200);

DESCRIBE USER;

-- UPDATE 
UPDATE USER
SET PROFILE_PICTURE = '/s3/profile-pic/profile-pic.png'
WHERE USER_ID = 1;

UPDATE USER
SET PROFILE_PICTURE = '/s3/profile-pic/profile-pic.png';

UPDATE USER
SET PROFILE_PICTURE = NULL;

SELECT * from USER;

-- ALTER TABLE 
ALTER TABLE USER
DROP COLUMN PROFILE_PICTURE;

-- DELETE
SELECT * FROM MEDIA_DETAILS;

SELECT * FROM POST_DETAILS;

DELETE FROM MEDIA_DETAILS
WHERE MEDIA_ID= 1;

-- DELETE THE FOREIGN KEY AND CREATE IT WITH CASCASE DELETE

ALTER TABLE POST_DETAILS
DROP FOREIGN KEY MEDIA_ID; -- MEDIA_ID FOREIGN KEY DOESN'T EXISTS

SHOW CREATE TABLE POST_DETAILS;

-- DROP THE FOREIGN KEY
ALTER TABLE POST_DETAILS
DROP FOREIGN KEY POST_DETAILS_ibfk_2;

-- CREATE THE FOREIGN KEY WITH CASCADE DELETE
ALTER TABLE POST_DETAILS
ADD CONSTRAINT FK_MEDIA_POST
FOREIGN KEY (MEDIA_ID) REFERENCES MEDIA_DETAILS(MEDIA_ID)
ON DELETE CASCADE;

DESCRIBE POST_DETAILS;


-- PROBLEM: Retrieve all posts with the user details who created the post.
SELECT P.POST_ID, P.CONTENT, P.POST_DATE, U.USER_NAME FROM
POST_DETAILS P INNER JOIN USER U 
ON P.USER_ID = U.USER_ID;

-- PROBLEM: List all users and their posts, including users who haven't posted anything yet.
SELECT U.USER_NAME, P.POST_ID, P.CONTENT FROM
USER U LEFT JOIN POST_DETAILS P
ON U.USER_ID = P.USER_ID;

-- PROBLEM: List all posts and the users who made them, including posts without user information (if any).
SELECT P.POST_ID, P.CONTENT, U.USER_NAME 
FROM USER U RIGHT JOIN POST_DETAILS P
ON U.USER_ID = P.USER_ID;

-- PROBLEM: List all users and their posts, including users without posts and posts without user information.

-- AS FULL OUTTER JOIN IS NOT SUPPORTED BY MY SQL, WE ARE GONNA MIMIC IT USING UNION AND LEFT AND RIGHT JOIN

SELECT U.USER_NAME, P.POST_ID, P.CONTENT
FROM USER U
LEFT JOIN POST_DETAILS P ON U.USER_ID = P.USER_ID

UNION

SELECT U.USER_NAME, P.POST_ID, P.CONTENT
FROM USER U
RIGHT JOIN POST_DETAILS P ON U.USER_ID = P.USER_ID;

-- PROBLEM: List all users who have friends along with their friend's names.
SELECT U1.USER_NAME AS USER, U2.USER_NAME AS FRIEND, F.FRIENDSHIP_SINCE
FROM FRIENDSHIP_DETAILS F
JOIN USER U1 ON F.USER_ID_1 = U1.USER_ID
JOIN USER U2 ON F.USER_ID_2 = U2.USER_ID;


-- PROBLEM: Retrieve all comments on posts with user details and post content.
SELECT C.COMMENT_ID, C.CONTENT AS COMMENT, U.USER_NAME, P.CONTENT AS POST
FROM COMMENT_DETAILS C
INNER JOIN USER U ON C.USER_ID = U.USER_ID
INNER JOIN POST_DETAILS P ON C.POST_ID = P.POST_ID;

-- PROBLEM: GET POSTS WHICH HAVE REACTIONS
SELECT P.CONTENT, R.REF_ENTITY_ID AS POST, COUNT(*) AS TOTAL_REACTIONS FROM 
REACTION_DETAILS R INNER JOIN POST_DETAILS P
ON R.REF_ENTITY_ID = P.POST_ID
WHERE R.REF_ENTITY_TYPE = "POST"
GROUP BY P.CONTENT, R.REF_ENTITY_ID;

-- PROBLEM: GET ALL THE POSTS WITH REACTION COUNT
SELECT P.POST_ID, P.CONTENT, COUNT(R.REF_ENTITY_ID) AS TOTAL_REACTIONS
FROM POST_DETAILS P
LEFT JOIN REACTION_DETAILS R 
ON P.POST_ID = R.REF_ENTITY_ID 
AND R.REF_ENTITY_TYPE = 'POST'
GROUP BY P.POST_ID;


-- GROUP BY WITH HAVING, get users who have atleast 1 friend
SELECT U.USER_ID, U.USER_NAME, COUNT(F.FREINDSHIP_HASH) AS TOTAL_FRIENDS
FROM USER U
JOIN FRIENDSHIP_DETAILS F 
ON U.USER_ID = F.USER_ID_1 OR U.USER_ID = F.USER_ID_2
GROUP BY U.USER_ID, U.USER_NAME
HAVING TOTAL_FRIENDS >= 1;



-- CREATE A PROCEDURE

select * from `USER`;
select * from FRIENDSHIP_DETAILS;

DROP PROCEDURE IF EXISTS GET_USER_DETAILS;

DELIMITER $$
CREATE PROCEDURE GET_USER_FRIENDS(IN USERID INT)
BEGIN
    SELECT * FROM USER where USER_ID = USERID;
END $$
DELIMITER ;

CALL GET_USER_FRIENDS(1);

-- GET THE PROCEDURES
SELECT ROUTINE_NAME, ROUTINE_TYPE, CREATED 
FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_SCHEMA = 'SOCIAL_MEDIA_APP';


-- VERSION CONTROL USING VERSION COLUMN IN REACTION TABLE.
ALTER TABLE REACTION_DETAILS ADD COLUMN VERSION INT DEFAULT 1;

select * from REACTION_DETAILS;

DROP TRIGGER IF EXISTS BEFORE_REACTION_UPDATE;

DELIMITER $$
CREATE TRIGGER BEFORE_REACTION_UPDATE
BEFORE UPDATE ON REACTION_DETAILS
FOR EACH ROW
BEGIN
    DECLARE ERROR_MESSAGE VARCHAR(255);
    
    -- Check if incoming version is greater than current version
    IF NEW.VERSION <= OLD.VERSION THEN
        SET ERROR_MESSAGE = CONCAT('Version Mismatch: Incoming version ', NEW.VERSION, ' is not greater than existing version ', OLD.VERSION);
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = ERROR_MESSAGE;
    END IF;

    -- If the version is correct, increment version automatically
    SET NEW.VERSION = OLD.VERSION + 1;
END $$

DELIMITER ;

INSERT INTO REACTION_DETAILS (REF_ENTITY_ID, USER_ID, REACTION_TYPE, REACTION_DATE, REF_ENTITY_TYPE, VERSION)
VALUES (300, 1, 'LIKE', '2025-02-28', 'POST', 1);

SELECT * FROM REACTION_DETAILS; 

UPDATE REACTION_DETAILS
SET REACTION_TYPE = 'HAHA', VERSION = 3
WHERE REACTION_ID = 7;

UPDATE REACTION_DETAILS
SET REACTION_TYPE = 'HAHA', VERSION = 2
WHERE REACTION_ID = 7; -- FAILS due to Version Mismatch


-- Lets Try to fit in a Procedure inside a trigger

-- LETS CREATE A PROCEDURE
DELIMITER $$

CREATE PROCEDURE INCREMENT_VERSION(
    IN OLD_VERSION INT,
    OUT NEW_VERSION INT
)
BEGIN
    SET NEW_VERSION = OLD_VERSION + 1;
END $$

DELIMITER ;

-- use the same version controlled Trigger and update it
DROP TRIGGER IF EXISTS BEFORE_REACTION_UPDATE;

DELIMITER $$

CREATE TRIGGER BEFORE_REACTION_UPDATE
BEFORE UPDATE ON REACTION_DETAILS
FOR EACH ROW
BEGIN
    DECLARE ERROR_MESSAGE VARCHAR(255);
    DECLARE UPDATED_VERSION INT;

    -- Check if incoming version is not greater than current version
    IF NEW.VERSION <= OLD.VERSION THEN
        SET ERROR_MESSAGE = CONCAT('Version Mismatch: Incoming version ', NEW.VERSION, ' is not greater than existing version ', OLD.VERSION);
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = ERROR_MESSAGE;
    END IF;

    -- Call the Procedure to Increment Version
    CALL INCREMENT_VERSION(OLD.VERSION, UPDATED_VERSION);

    -- Set the new version
    SET NEW.VERSION = UPDATED_VERSION;
    
END $$

DELIMITER ;

SELECT * FROM REACTION_DETAILS;

-- UPDATE THROWS ERROR
UPDATE REACTION_DETAILS
SET REACTION_TYPE = 'LOVE', VERSION = 2
WHERE REACTION_ID = 1;



DROP VIEW IF EXISTS VIEW_REACTION_COUNT
-- Create a VIEW
CREATE OR REPLACE VIEW VIEW_REACTION_COUNT AS
SELECT REF_ENTITY_ID, REF_ENTITY_TYPE, REACTION_TYPE, COUNT(*) AS REACTION_COUNT
FROM REACTION_DETAILS
GROUP BY REF_ENTITY_ID, REF_ENTITY_TYPE, REACTION_TYPE;

CREATE OR REPLACE VIEW REACTION_DETAILS_VIEW AS
SELECT REF_ENTITY_ID, REF_ENTITY_TYPE, REACTION_TYPE FROM REACTION_DETAILS;

-- SELECT FROM VIEW
SELECT * FROM VIEW_REACTION_COUNT;

SELECT * FROM REACTION_DETAILS_VIEW;
SELECT * FROM REACTION_DETAILS;

-- CHECK if a VIEW IS UPDATABLE OR NOT
SELECT TABLE_NAME, IS_UPDATABLE 
FROM INFORMATION_SCHEMA.VIEWS
WHERE TABLE_NAME = 'REACTION_DETAILS_VIEW';

SELECT TRIGGER_NAME, EVENT_MANIPULATION, ACTION_STATEMENT 
FROM INFORMATION_SCHEMA.TRIGGERS 
WHERE TRIGGER_SCHEMA = 'SOCIAL_MEDIA_APP' 
AND EVENT_OBJECT_TABLE = 'REACTION_DETAILS';


-- Single Base Table - can be updated
-- No Group By or Aggregate Functions
-- No DISTINCT	
-- No Joins (Simple Join Views are not updatable by default)
-- No Subqueries in SELECT	
-- No UNION or UNION ALL